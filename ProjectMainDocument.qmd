---
1--
title: "Project Main Document"
format: html
editor: visual
---

## Data Analytics Group Project

Group Members: Zack, Mustapha, Kerim, Chris

## Heart Failure Prediction

#### About the Data set:

This dataset contains clinical data from 300 heart failure patients collected at two hospitals in Pakistan. It includes 13 columns such as age, blood test results like creatinine phosphokinase and serum creatinine levels, vital signs like ejection fraction, and presence of conditions like anemia, diabetes, and high blood pressure. Lifestyle factors like smoking status are also recorded. Crucially, it has a binary target variable indicating if the patient survived or experienced a death event during the follow-up period averaging 130 days. With 96 patients deceased and 203 surviving, this dataset is imbalanced but provides a valuable opportunity to analyze risk factors and develop predictive models for mortality in heart failure cases. The diverse clinical features make it a rich resource for applying machine learning techniques to improve heart failure prognosis and management.

#### **Description of Data set:**

This data set contains information on people with cardiovascular disease, including age and health conditions. The purpose of the data set is to be used to create a predictive model to help those who are at risk or have cardiovascular disease prevent heart failure through early detection. This data set has 13 attributes that can be used to predict mortality by heart failure.

#### **Cleaning the Data:**

```{r}
library(tidyverse)
library("dplyr")
library(caret)
library(rpart)
library(pROC)
library(xgboost)

heart <- read.csv("heart_failure_clinical_records_dataset.csv")
heart

```

Check for missing values:

```{r}
mean(heart$age)
mean(heart$anaemia)
mean(heart$creatinine_phosphokinase)
mean(heart$diabetes)
mean(heart$ejection_fraction)
mean(heart$high_blood_pressure)
mean(heart$platelets)
mean(heart$serum_creatinine)
mean(heart$serum_sodium)
mean(heart$sex)
mean(heart$smoking)
mean(heart$time)
mean(heart$DEATH_EVENT)

mean(heart$serum_creatinine <= 2)
```

This means that there are no missing values in the data set, because if there were missing values, then the mean would result in a value of NA for the given attribute.

Check for outliers:

```{r}
boxplot(heart$age)
boxplot(heart$creatinine_phosphokinase)
boxplot(heart$ejection_fraction)
boxplot(heart$platelets)
boxplot(heart$serum_creatinine)
boxplot(heart$serum_sodium)
boxplot(heart$time)
```

While there are several outliers in some of the attributes, I would not make sense to remove them from the data set. This is because there is a large quantity of outliers, and removing them would have a significant effect on the total amount of data in the data set. The example below shows how removing the outliers can affect the data.

```{r}
mean(heart$serum_creatinine)

no_outlier_data <- heart[-which(heart$creatinine_phosphokinase==3964),]

mean(no_outlier_data$serum_creatinine)
```

```{r}
#(heart$creatinine_phosphokinase)
#(heart$platelets)
#heart$serum_creatinine)
#heart$serum_sodium)
  
ggplot(heart, aes(x = creatinine_phosphokinase, y = platelets)) +
  geom_point()

ggplot(heart, aes(x = creatinine_phosphokinase, y = serum_creatinine)) +
  geom_point()

ggplot(heart, aes(x = creatinine_phosphokinase, y = serum_sodium)) +
  geom_point()

ggplot(heart, aes(x = serum_creatinine, y = platelets)) +
  geom_point()

ggplot(heart, aes(x = serum_sodium, y = platelets)) +
  geom_point()

ggplot(heart, aes(x = serum_creatinine, y = serum_sodium)) +
  geom_point()
```

By looking at the graphs of the continuous variables, we can identify any outlier samples that are outliers in more than one attribute. In this data set, almost all of the samples with an outlier have only one outlier, with only one sample with outliers in both creatinine phosphokinase and serum creatinine, which could be removed. To determine if the values should be removed, we need to look at the plausible ranges for the different attriibutes.

-   Age: Ranges from 40 to 95 years, which seems plausible for a heart failure clinical records dataset.

-   Creatinine Phosphokinase: Has a wide range (23 to 7861), with a large standard deviation, indicating significant variability. The maximum value is notably high, which may be worth investigating further.

-   Ejection Fraction: Ranges from 14% to 80%, which covers the expected range for this clinical measure, though the upper range is quite high.

-   Platelets: The count ranges widely from 25100 to 850000, with a standard deviation that suggests variability but within a plausible range.

-   Serum Creatinine: Ranges from 0.5 to 9.4, with the higher end being concerning and indicative of severe renal dysfunction, which is plausible in the context of heart failure but could be considered an outlier.

-   Serum Sodium: Ranges from 113 to 148, with values mostly concentrating around the normal range, though the extremes indicate potential clinical concerns or measurement errors.

-   Sex, Smoking, Diabetes, Anaemia, High Blood Pressure, and DEATH_EVENT: Are binary variables coded as 0 or 1, with their distributions looking plausible for clinical data.

-   Time: Represents the follow-up period in days, with a range from 4 to 285.

Looking at these value ranges, we can see that these values are not outside of the plausible range for each attribute, so none of the values are errors. These high values are physically possible and can help us to determine why the person might have suffered heart failure.

```{r}
ggplot(heart, aes(x = age)) +
  geom_bar()
ggplot(heart, aes(x = anaemia)) +
  geom_bar()
ggplot(heart, aes(x = age, y = creatinine_phosphokinase)) +
  geom_point()
ggplot(heart, aes(x = diabetes)) +
  geom_bar()
ggplot(heart, aes(x = age, y = ejection_fraction)) +
  geom_point()
ggplot(heart, aes(x = high_blood_pressure)) +
  geom_bar()
ggplot(heart, aes(x = age, y = platelets)) +
  geom_point()
ggplot(heart, aes(x = age, y = serum_creatinine)) +
  geom_point()
ggplot(heart, aes(x = age, y = serum_sodium)) +
  geom_point()
ggplot(heart, aes(x = sex)) +
  geom_bar()
ggplot(heart, aes(x = DEATH_EVENT)) +
  geom_bar()
```

## **Analysis of Attributes:**

### Variation Analysis:

#### Age

```{r}
age_summ <- heart |>
  summarise(Mean = mean(age, na.rm = TRUE),
    Median = median(age, na.rm = TRUE),
    Standard_Deviation = sd(age, na.rm = TRUE),
    IQR = IQR(age, na.rm = TRUE))

print(age_summ)

ggplot(heart, aes(x = age)) +
  geom_histogram(binwidth = 1) +
  labs(title = "Distribution of Age", x = "Age", y = "Count")

ggplot(heart, aes(y = age)) +
  geom_boxplot() +
  labs(title = "Boxplot of Age", y = "Age")

```

The mean and the median values for age are about 60 years old. The values somewhat follow a normal distribution around 60, with most values being between 50 and 70 and fewer samples at 40 and 80 and some outliers around 90. This distribution makes sense because people with heart disease are more likely to have a heart failure relatively earlier in their life and a shorter overall life expectancy.

#### Creatinine Phosphokinase

```{r}
creatinine_phosphokinase_summ <- heart |>
  summarise(Mean = mean(creatinine_phosphokinase, na.rm = TRUE),
    Median = median(creatinine_phosphokinase, na.rm = TRUE),
    Standard_Deviation = sd(creatinine_phosphokinase, na.rm = TRUE),
    IQR = IQR(creatinine_phosphokinase, na.rm = TRUE))

print(creatinine_phosphokinase_summ)

ggplot(heart, aes(x = creatinine_phosphokinase)) +
  geom_histogram(binwidth = 100) +
  labs(title = "Distribution of Creatinine Phosphokinase", x = "Creatinine Phosphokinase", y = "Count")

variance_cpk <- var(heart$creatinine_phosphokinase)

ggplot(heart, aes(x = creatinine_phosphokinase)) +
  geom_boxplot(fill = "skyblue", width = 0.7) +
  coord_flip() +
  labs(title = "Boxplot of Creatinine Phosphokinase",
       y = "creatinine_phosphokinase") +
  theme(axis.title.y = element_blank())  

print(variance_cpk)
```

The high coefficient of variation indicates that the creatinine phosphokinase levels vary widely among the patients in this dataset. This wide variation suggests that the levels can be extremely variable from one patient to another, which could be due to individual differences or varying severities of heart conditions.

#### Ejection Fraction

```{r}
ejection_fraction_summ <- heart |>
  summarise(Mean = mean(ejection_fraction, na.rm = TRUE),
    Median = median(ejection_fraction, na.rm = TRUE),
    Standard_Deviation = sd(ejection_fraction, na.rm = TRUE),
    IQR = IQR(ejection_fraction, na.rm = TRUE))

print(ejection_fraction_summ)

ggplot(heart, aes(x = ejection_fraction)) +
  geom_histogram(binwidth = 1) +
  labs(title = "Distribution of Ejection Fraction", x = "Ejection Fraction", y = "Count")

variance_ef <- var(heart$ejection_fraction)

ggplot(heart, aes(x = ejection_fraction)) +
  geom_boxplot(fill = "skyblue", width = 0.7) +
  coord_flip() +  # Flip coordinates to make boxplot horizontal
  labs(title = "Boxplot of Ejection Fraction",
       y = "Ejection Fraction (%)") +
  theme(axis.title.y = element_blank())  
print(variance_ef)

```

The moderate coefficient of variation for ejection fraction suggests that while there is some variability in how well the heart pumps blood with each beat, it is less varied compared to creatinine phosphokinase. This might reflect a somewhat consistent measure of heart function among patients with heart failure.

#### Platelets

```{r}
platelets_summ <- heart |>
  summarise(Mean = mean(platelets, na.rm = TRUE),
    Median = median(platelets, na.rm = TRUE),
    Standard_Deviation = sd(platelets, na.rm = TRUE),
    IQR = IQR(platelets, na.rm = TRUE))

print(platelets_summ)

#summary(heart$platelets) 
ggplot(heart, aes(x = platelets)) + geom_histogram(binwidth = 10000) + labs(title = "Distribution of Platelet Levels") 

ggplot(heart, aes(y = platelets)) +
  geom_boxplot() +
  labs(title = "Boxplot of Platelets", y = "Platelets")

```

The x-axis represents the platelet count, divided into bins, and the y-axis represents the count of observations within each bin. The histogram shows a multimodal distribution, with the most prominent peak around 250,000 platelets. There are smaller peaks observed at lower and higher platelet counts. The distribution has a long tail extending towards higher platelet counts, indicating some higher values in the dataset, though these are less frequent.

#### Serum Creatinine

```{r}
serum_creatinine_summ <- heart |>
  summarise(Mean = mean(serum_creatinine, na.rm = TRUE),
    Median = median(serum_creatinine, na.rm = TRUE),
    Standard_Deviation = sd(serum_creatinine, na.rm = TRUE),
    IQR = IQR(serum_creatinine, na.rm = TRUE))

print(serum_creatinine_summ)

#summary(heart$serum_creatinine) 
ggplot(heart, aes(x = serum_creatinine)) + geom_histogram(binwidth = 0.1) + labs(title = "Distribution of Serum Creatinine Levels") 

ggplot(heart, aes(y = serum_creatinine)) +
  geom_boxplot() +
  labs(title = "Boxplot of Serum Creatinine", y = "Serum Creatinine")

```

This is a histogram that shows the frequency distribution of serum creatinine levels among a sample population.The x-axis is labeled "serum_creatinine" and ranges from 0 to 7.5, indicating the serum creatinine levels in mg/dL.The y-axis is labeled "count" and shows the number of occurrences for each serum creatinine level.The histogram peaks around 1.0 mg/dL, suggesting that this is the most common serum creatinine level in the sample. The distribution is right-skewed, indicating that higher creatinine levels are less common but extend to about 7.5 mg/dL.

#### Serum Sodium

```{r}

serum_sodium_summary <- heart %>%

  summarise(

    Mean = mean(serum_sodium, na.rm = TRUE),

    Median = median(serum_sodium, na.rm = TRUE),

    Standard_Deviation = sd(serum_sodium, na.rm = TRUE),

    IQR = IQR(serum_sodium, na.rm = TRUE)

  )

print(serum_sodium_summary)

ggplot(heart, aes(x = serum_sodium)) +

  geom_histogram(binwidth = 1, fill = "blue", color = "black") +

  labs(title = "Distribution of Serum Sodium Levels", x = "Serum Sodium", y = "Count")

ggplot(heart, aes(y = serum_sodium)) +

  geom_boxplot(fill = "lightblue", color = "black") +

  labs(title = "Boxplot of Serum Sodium Levels", y = "Serum Sodium")
```

1.  Boxplot of Serum Sodium Levels: The boxplot indicates that the median serum sodium level is around 135 mEq/L, which is within normal serum sodium ranges, but there are several outliers on the lower side indicating patients with hyponatremia.

2.  Distribution of Serum Sodium Levels: This histogram shows a left-skewed distribution, suggesting that a lower serum sodium level is less common but present in the patient population, which can be critical in heart failure management.

#### Time

```{r}

time_summary <- heart %>%

  summarise(

    Mean = mean(time, na.rm = TRUE),

    Median = median(time, na.rm = TRUE),

    Standard_Deviation = sd(time, na.rm = TRUE),

    IQR = IQR(time, na.rm = TRUE)

  )

print(time_summary)

ggplot(heart, aes(x = time)) +

  geom_histogram(binwidth = 10, fill = "green", color = "black") +

  labs(title = "Distribution of Time", x = "Time", y = "Count")

ggplot(heart, aes(y = time)) +

  geom_boxplot(fill = "lightgreen", color = "black") +

  labs(title = "Boxplot of Time", y = "Time")


```

1.  Distribution of Time: This histogram displays the follow-up period 'time' with a varied distribution, indicating that the follow-up times were not uniform across patients, which might affect longitudinal analyses.

2.  Summary Statistics: The mean serum sodium is higher than the median, confirming the skewness seen in the histogram. The interquartile range (IQR) is 130 mEq/L, indicating a moderate spread in serum sodium levels among patients.

### Covariation Analysis:

##### Serum Creatinine vs Serum Sodium

Serum Creatinine and Serum Sodium have a slight negative correlation, where as serum sodium increases, serum creatinine tends to decrease. The p-value for this correlation is less than 0.5, which means the correlation between serum creatinine and serum sodium is significant.

##### Serum Creatinine vs Time

Serum Creatinine and Time have a negative correlation, where as serum creatinine increase, the time, which is the number of days in the follow up period, decreases. The p-value for this correlation is less than 0.5, which means the correlation between serum creatinine and time is significant.

##### Serum Sodium vs Time

The regression for Serum Sodium and Time shows a positive trend, where as serum sodium increases, the number of days in the follow up period also increases. However, the p-value is greater than 0.5, which means we accept the null hypothesis, which is that there is no significant correlation between serum sodium and time.

```{r}
cor_sc_ss <- cor.test(heart$serum_creatinine, heart$serum_sodium)
cor_sc_t <- cor.test(heart$serum_creatinine, heart$time)
cor_ss_t <- cor.test(heart$serum_sodium, heart$time)

print(paste("Correlation between serum_creatinine and serum_sodium:"))
cor_sc_ss
print(paste("Correlation between serum_creatinine and time:"))
cor_sc_t
print(paste("Correlation between platelets and serum_sodium:"))
cor_ss_t


ggplot(heart, aes(x = serum_creatinine, y = serum_sodium)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(title = "Serum Creatinine vs Serum Sodium")

ggplot(heart, aes(x = serum_creatinine, y = time)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(title = "Serum Creatinine vs Time")

ggplot(heart, aes(x = serum_sodium, y = time)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "red" ) +
  labs(title = "Serum Sodium vs Time")
```

##### Creatinine Phosphokinase vs Ejection Fraction

There is a very weak negative correlation between creatinine phosphokinase levels and ejection fraction. This suggests that there is no significant linear relationship between these variables.

##### Creatinine Phosphokinase vs Platelets

The correlation is very weakly positive, indicating that there is essentially no meaningful linear relationship between creatinine phosphokinase levels and platelet counts.

##### Creatinine Phosphokinase vs Serum Creatinine

This very weak negative correlation suggests that changes in creatinine phosphokinase levels do not reliably predict changes in serum creatinine levels.

##### Creatinine Phosphokinase vs Serum Sodium

A weak positive correlation is observed here, but it is not strong enough to indicate a significant linear relationship. Variations in creatinine phosphokinase seem to have little effect on serum sodium levels.

```{r}
cor_cpk_ef <- cor.test(heart$creatinine_phosphokinase, heart$ejection_fraction)
cor_cpk_p <- cor.test(heart$creatinine_phosphokinase, heart$platelets)
cor_cpk_sc <- cor.test(heart$creatinine_phosphokinase, heart$serum_creatinine)
cor_cpk_ss <- cor.test(heart$creatinine_phosphokinase, heart$serum_sodium)

print(paste("Correlation between creatinine_phosphokinase and ejection_fraction:"))
cor_cpk_ef
print(paste("Correlation between creatinine_phosphokinase and platelets:")) 
cor_cpk_p
print(paste("Correlation between creatinine_phosphokinase and serum_creatinine:")) 
cor_cpk_sc
print(paste("Correlation between creatinine_phosphokinase and serum_sodium:")) 
cor_cpk_ss

p1 <- ggplot(heart, aes(x=creatinine_phosphokinase, y=ejection_fraction)) +
  geom_point() +
  geom_smooth(method="lm", se = FALSE, color="red") +
  labs(title="Scatter Plot\nCreatinine Phosphokinase vs Ejection Fraction",
       x="Creatinine Phosphokinase (units/L)", y="Ejection Fraction (%)")

p2 <- ggplot(heart, aes(x=creatinine_phosphokinase, y=platelets)) +
  geom_point() +
  geom_smooth(method="lm", se = FALSE, color="red") +
  labs(title="Scatter Plot\nCreatinine Phosphokinase vs Platelets",
       x="Creatinine Phosphokinase (units/L)", y="Platelets (%)")

p3 <- ggplot(heart, aes(x=creatinine_phosphokinase, y=serum_creatinine)) +
  geom_point() +
  geom_smooth(method="lm", se = FALSE, color="red") +
  labs(title="Scatter Plot\nCreatinine Phosphokinase vs Serum Creatinine",
       x="Creatinine Phosphokinase (units/L)", y="Serum Creatinine (%)")

p4 <- ggplot(heart, aes(x=creatinine_phosphokinase, y=serum_sodium)) +
  geom_point() +
  geom_smooth(method="lm", se = FALSE, color="red") +
  labs(title="Scatter Plot\nCreatinine Phosphokinase vs Serum Sodium",
       x="Creatinine Phosphokinase (units/L)", y="Serum Sodium (%)")

print(p1)
print(p2)
print(p3)
print(p4)
```

##### Creatinine Phosphokinase vs Time

The image displays a scatter plot titled "Creatinine Phosphokinase vs Time". The x-axis, labeled "Time", appears to be measured in days, although the units are not explicitly stated. The y-axis is labeled "Creatinine Phosphokinase" and is measured in units (presumably U/L, a common unit for enzyme activity).The majority of the data points are clustered near the lower part of the y-axis, suggesting that most of the Creatinine Phosphokinase measurements are relatively low.There are several outliers with significantly higher Creatinine Phosphokinase values, some reaching up to 8000 U/L. A red trend line is drawn across the plot, which appears to be relatively flat, indicating that there is no strong  trend of increasing or decreasing Creatinine Phosphokinase levels over time

##### Ejection Fraction vs Platelets

The image displays a scatter plot titled "Ejection Fraction vs Platelets." This plot is used to visualize the relationship between the ejection fraction of the heart and the platelet count in the blood. The X Represents the platelet count, ranging from 0 to approximately 800,000. The Y Represents the ejection fraction, ranging from approximately 20% to 80%. The scatter plot consists of numerous black dots, each representing an individual data point correlating a specific platelet count to an ejection fraction value. A red line is drawn across the plot, indicating a trend line. This line appears to be relatively flat, suggesting that there might be a weak or no significant linear relationship between platelet count and ejection fraction based on the data presented.

##### Ejection Fraction vs Serum Creatinine

The image displays a scatter plot titled "Ejection Fraction vs Serum Creatinine." The x-axis represents serum creatinine levels, ranging from approximately 0.5 to 9.0 mg/dL, while the y-axis represents ejection fraction percentages, ranging from about 20% to 80%. The plot is populated with numerous data points, indicating individual measurements of ejection fraction at corresponding serum creatinine levels. A red line is drawn across the plot, which appears to be a trend line, although it is relatively flat, suggesting a weak or no significant correlation between serum creatinine levels and ejection fraction percentages based on the visual representation. 

##### Ejection Fraction vs Serum Sodium

The image displays a scatter plot titled "Ejection Fraction vs Serum Sodium." The x-axis is labeled "Serum Sodium" and ranges from 120 to 145. The y-axis is labeled "Ejection Fraction" and ranges from about 20 to 80. The plot contains numerous black data points scattered across the graph, indicating individual observations of serum sodium levels and their corresponding ejection fraction percentages. A red line is also present on the graph, representing a trend line (possibly a linear regression line) that suggests a positive correlation between serum sodium levels and ejection fraction. This implies that as serum sodium levels increase, there is a general increase in ejection fraction percentages.

```{r}
cor_cpk_t <- cor.test(heart$creatinine_phosphokinase, heart$time)
cor_ef_p <- cor.test(heart$ejection_fraction, heart$platelets)
cor_ef_sc <- cor.test(heart$ejection_fraction, heart$serum_creatinine)
cor_ef_ss <- cor.test(heart$ejection_fraction, heart$serum_sodium)

print(paste("Correlation between creatinine_phosphokinase and time:"))
cor_cpk_t
print(paste("Correlation between ejection_fraction and platelets:"))
cor_ef_p
print(paste("Correlation between ejection_fraction and serum_creatinine:"))
cor_ef_sc
print(paste("Correlation between ejection_fraction and serum_sodium:"))
cor_ef_ss

# Scatter plot of Creatinine Phosphokinase vs Time 
ggplot(heart, aes(x = time, y = creatinine_phosphokinase)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(x = "Time", y = "Creatinine Phosphokinase", title = "Creatinine Phosphokinase vs Time") 
 
 
# Scatter plot of Ejection Fraction vs Platelets 
ggplot(heart, aes(x = platelets, y = ejection_fraction)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(x = "Platelets", y = "Ejection Fraction", title = "Ejection Fraction vs Platelets") 
 
# Scatter plot of Ejection Fraction vs Serum Creatinine 
ggplot(heart, aes(x = serum_creatinine, y = ejection_fraction)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(x = "Serum Creatinine", y = "Ejection Fraction", title = "Ejection Fraction vs Serum Creatinine") 
 
# Scatter plot of Ejection Fraction vs Serum Sodium 
ggplot(heart, aes(x = serum_sodium, y = ejection_fraction)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(x = "Serum Sodium", y = "Ejection Fraction", title = "Ejection Fraction vs Serum Sodium") 

```

##### Ejection Fraction vs Time

Scatter plot of Ejection Fraction vs Time: The scatter plot with a slightly upward trend suggests a very weak positive correlation, meaning higher ejection fractions might be associated with longer follow-up times.

##### Platelets vs Serum Creatinine

Scatter plot of Platelets vs Serum Creatinine: The relatively flat fitted line suggests no significant linear relationship between platelet count and serum creatinine levels.

##### Platelets vs Serum Sodium

Scatter plot of Platelets vs Serum Sodium: The plot shows a weak upward trend, hinting at a weak positive relationship between platelets and serum sodium.

##### Platelets vs Time

Scatter plot of Platelets vs Time: The flat trend line suggests no clear linear relationship between platelets and follow-up time.

```{r}

cor_ejection_fraction_time <- cor.test(heart$ejection_fraction, heart$time, use = "complete.obs")

cor_platelets_serum_creatinine <- cor.test(heart$platelets, heart$serum_creatinine, use = "complete.obs")

cor_platelets_serum_sodium <- cor.test(heart$platelets, heart$serum_sodium, use = "complete.obs")

cor_platelets_time <- cor.test(heart$platelets, heart$time, use = "complete.obs")

print(paste("Correlation between ejection_fraction and time:"))
cor_ejection_fraction_time

print(paste("Correlation between platelets and serum_creatinine:")) 
cor_platelets_serum_creatinine

print(paste("Correlation between platelets and serum_sodium:")) 
cor_platelets_serum_sodium

print(paste("Correlation between platelets and time:")) 
cor_platelets_time

ggplot(heart, aes(x = ejection_fraction, y = time)) +

  geom_point() +

  geom_smooth(method = "lm", se = FALSE, color = "blue") +

  labs(title = "Scatter plot of Ejection Fraction vs Time")

ggplot(heart, aes(x = platelets, y = serum_creatinine)) +

  geom_point() +

  geom_smooth(method = "lm", se = FALSE, color = "red") +

  labs(title = "Scatter plot of Platelets vs Serum Creatinine")

ggplot(heart, aes(x = platelets, y = serum_sodium)) +

  geom_point() +

  geom_smooth(method = "lm", se = FALSE, color = "green" ) +

  labs(title = "Scatter plot of Platelets vs Serum Sodium")

ggplot(heart, aes(x = platelets, y = time)) +

  geom_point() +

  geom_smooth(method = "lm", se = FALSE, color = "orange") +

  labs(title = "Scatter plot of Platelets vs Time")
```

## Research Questions:

1.  **Can we predict which patients are likely to have a serum sodium level below the normal range based** **on their other attributes?**

    We could use Linear regression , if serum creatinine levels are treated as a continuous dependent variable and multiple regression if there are non linear relationships

    ```{r}
    train_indices <- sample(1:nrow(heart), 0.7 * nrow(heart)) 
    test_indices <- setdiff(1:nrow(heart), train_indices)
    train_data <- heart[train_indices, ]
    test_data <- heart[test_indices, ]

    xgb_model <- train(
      ejection_fraction ~ ., 
      data = train_data, 
      method = "xgbTree", 
      trControl = trainControl(method = "cv", number = 5),
      verbose = FALSE
    )

    # Make predictions on test data
    xgb_predictions <- predict(xgb_model, newdata = test_data)

    # Evaluate model performance
    rmse <- sqrt(mean((xgb_predictions - test_data$ejection_fraction)^2))
    cat("Root Mean Squared Error (RMSE):", rmse, "\n")

    # Visualize actual vs. predicted ejection fraction levels
    plot(test_data$ejection_fraction, xgb_predictions,
         xlab = "Actual Ejection Fraction", 
         ylab = "Predicted Ejection Fraction",
         main = "Actual vs. Predicted Plot (XGBoost)")
    abline(0, 1, col = "red")

    train_indices <- sample(1:nrow(heart), 0.7 * nrow(heart)) 
    test_indices <- setdiff(1:nrow(heart), train_indices)
    train_data <- heart[train_indices, ]
    test_data <- heart[test_indices, ]
    library(ggplot2)
    lm_model <- lm(ejection_fraction ~ ., data = train_data)
    lm_predictions <- predict(lm_model, newdata = test_data)
    rmse <- sqrt(mean((lm_predictions - test_data$ejection_fraction)^2))
    cat("Root Mean Squared Error (RMSE):", rmse, "\n")
    rsquared <- summary(lm_model)$r.squared
    cat("R-squared (R²) Value:", rsquared, "\n")
    ggplot(data = test_data, aes(x = ejection_fraction, y = lm_predictions)) +
      geom_point() +
      geom_abline(intercept = 0, slope = 1, color = "red") +
      labs(x = "Actual Ejection Fraction", y = "Predicted Ejection Fraction",
           title = "Actual vs. Predicted Plot (Linear Regression)")
    threshold <- 50 
    test_data$predicted_below_normal <- ifelse(lm_predictions < threshold, "Yes", "No")
    ggplot(data = test_data, aes(x = ejection_fraction, y = lm_predictions, color = predicted_below_normal)) +
      geom_point() +
      geom_abline(intercept = 0, slope = 1, color = "red") +
      labs(x = "Actual Ejection Fraction", y = "Predicted Ejection Fraction",
           title = "Actual vs. Predicted Plot (Linear Regression)",
           color = "Predicted Below Normal") +
      scale_color_manual(values = c("Yes" = "blue", "No" = "green"))


    ```

    Both models showed poor predictive abilities. The RMSE was 11.92, 11.91,  which further shows that both models are not accurately predicting ejection fraction levels based on the other attributes. The high rsme indicates a large average deviation between the predicted and the actual results. Thus, with our current models the predictions are not accurate.

2.  **Is it possible to model serum creatinine levels as a function of the remaining attributes?**

    Modeling serum creatinine levels as a function of the remaining attributes in heart failure prediction is a relevant and potentially valuable approach. Serum creatinine is a crucial biomarker that reflects kidney function, and elevated levels can indicate impaired renal function, which is often associated with heart failure. By exploring the relationships between serum creatinine and other attributes, such as age, gender, blood pressure, smoking status, and various laboratory tests, researchers may gain insights into the factors that influence creatinine levels and, consequently, kidney function. This understanding could potentially aid in the early detection of renal impairment, a common complication in heart failure patients, and contribute to more accurate risk stratification and personalized treatment strategies. Consequently, this question was chosen to investigate the potential predictors of serum creatinine levels and their implications for heart failure risk assessment.

    ```{r}
    train_indices <- sample(1:nrow(heart), 0.7 * nrow(heart)) 
    test_indices <- setdiff(1:nrow(heart), train_indices)
    train_data <- heart[train_indices, ]
    test_data <- heart[test_indices, ]

    lm_model <- lm(serum_creatinine ~ ., data = train_data)
    lm_predictions <- predict(lm_model, newdata = test_data)
    rmse <- sqrt(mean((lm_predictions - test_data$serum_creatinine)^2))
    cat("Root Mean Squared Error (RMSE):", rmse, "\n")
    fitted_values <- fitted(lm_model)
    residuals <- resid(lm_model)
    plot(fitted_values, residuals, 
         xlab = "Fitted Values", 
         ylab = "Residuals",
         main = "Residuals vs. Fitted Plot")
    abline(h = 0, col = "red")

    rsquared <- summary(lm_model)$r.squared
    cat("R-squared (R²) Value:", rsquared, "\n")
    plot(test_data$serum_creatinine, lm_predictions, 
         xlab = "Actual Serum Creatinine", 
         ylab = "Predicted Serum Creatinine",
         main = "Actual vs. Predicted Plot")
    abline(0, 1, col = "red")
    lm_summary <- summary(lm_model)
    cat("\nAdditional Information:\n")
    print(lm_summary)

    ```

    Based on the output it is possible to model serum creatinine levels as a function of the remaining attributes. The model provided evidence supporting this. Also, the model’s R-squared was around 41%. Thus, based on the results of the linear regression analysis, it is possible to model serum creatinine levels. Serum sodium has a coefficient of 0.047 and a p-value of 0.0399 which shows significance. Moreover, higher serum sodium levels are associated with higher levels of serum creatinine. 

3.  **Can we classify patients into low, medium, and high risk for heart complications based on their platelet count and ejection fraction?**

    We can use a logistic regression model, decision tree, or svm model with all of the patients attributes as the independent variables and death event as the dependent variable. We can separate into risk categories by dividing the test samples into three categories based on the predicted probabilities.

```{r}
#----------------------------------------------
#Test data
test_model <- glm(DEATH_EVENT ~ ., data = train_data, family = binomial)
summary(test_model)

```

By looking at the p-values above, we can see that the only attributes with a significant relationship with DEATH_EVENT (p-value less than 0.05) are age, ejection_fraction, serum_creatinine, and time. These attributes will be our independent variables in our different models.

```{r}
#----------------------------------------------
set.seed(123)
train_indices <- sample(1:nrow(heart), 0.7 * nrow(heart)) 
test_indices <- setdiff(1:nrow(heart), train_indices)  
train_data <- heart[train_indices, ]
test_data <- heart[test_indices, ]

train_data$DEATH_EVENT <- factor(train_data$DEATH_EVENT)
test_data$DEATH_EVENT <- factor(test_data$DEATH_EVENT)

#Logistic Regression Model

log_model <- glm(DEATH_EVENT ~ age + ejection_fraction + serum_creatinine + time, data = train_data, family = binomial)
summary(log_model)
log_predictions <- predict(log_model, newdata = test_data, type = "response")

log_predicted_classes <- ifelse(log_predictions > 0.5, "1", "0")
print(paste("Logistic Regression Accuracy: ", mean(log_predicted_classes == test_data$DEATH_EVENT)))

log_predicted_classes <- factor(log_predicted_classes)
log_conf_matrix <- confusionMatrix(log_predicted_classes, test_data$DEATH_EVENT, positive = "1")
print(log_conf_matrix)


#-----------------------------------------------------------
#SVM

svm_model <- train(
  DEATH_EVENT ~ age + ejection_fraction + serum_creatinine + time , data = train_data, method = "svmLinear",
  trControl = trainControl(method = "cv", number = 10),
  preProcess = c("center","scale")
)

svm_predictions <- svm_model |> predict(test_data)

print(paste("SVM Accuracy: ", mean(svm_predictions == test_data$DEATH_EVENT)))

svm_conf_matrix <- confusionMatrix(svm_predictions, test_data$DEATH_EVENT, positive = "1")
print(svm_conf_matrix)

#-----------------------------------------------------------
#Decision Tree

dec_model <- rpart(DEATH_EVENT ~ age + ejection_fraction + serum_creatinine + time, data = train_data, method="class")

dec_predicted_classes <- dec_model |>
  predict(test_data, type="class")
print(paste("Decision Tree Accuracy: ", mean(dec_predicted_classes == test_data$DEATH_EVENT)))

dec_conf_matrix <- confusionMatrix(dec_predicted_classes, test_data$DEATH_EVENT, positive = "1")
print(dec_conf_matrix)


#----------------------------------------------------------
#ROC
res.roc <- roc(as.numeric(test_data$DEATH_EVENT), as.numeric(log_predicted_classes))
plot.roc(res.roc, print.auc = TRUE)

res.roc <- roc(as.numeric(test_data$DEATH_EVENT), as.numeric(svm_predictions))
plot.roc(res.roc, print.auc = TRUE)

res.roc <- roc(as.numeric(test_data$DEATH_EVENT), as.numeric(dec_predicted_classes))
plot.roc(res.roc, print.auc = TRUE)

```

When comparing these models, they all have an overall accuracy that is similar, but the most important part of the accuracy to look at is the Type II error. Type II error is a false negative, and with this model, this is much worse than Type I error because Type II error is predicting a person will not die, but they did die, while Type I error is predicting a person will die, but they live. For the logistic regression model, the sensitivity is 0.5517. For the SVM model, the sensitivity is also 0.5517. Finally, for the Decision Tree model, the sensitivity is 0.6897. This means that the Decision Tree model is less likely to incorrectly classify a positive result as a negative when compared to the other models. Therefore, the Decision Tree is the best model to predict the potential outcomes for the patients. However, the question wants us to divide the patients into three risk groups (low, medium, and high risk), and the Decision Tree gives us predictions in the binary value of DEATH_EVENT, so we cannot easily divide the patients into three groups. Therefore, we should use logistic regression for categorizing the patients into risk categories.

```{r}
#------------------------------------------------------------
#Divide into risk categories

low <- 0.33
medium <- 0.66

risk_category <- ifelse(log_predictions < low, "Low",
                                 ifelse(log_predictions > medium, "High", "Medium"))

risk_data <- data.frame(age = test_data$age, ejection_fraction = test_data$ejection_fraction, serum_creatinine = test_data$serum_creatinine, time = test_data$time, risk_category = risk_category)
risk_data
```

By using the above table, we are able to assess a patient’s risk level for death from heart failure based on the significant attributes of the patient.

4.  **Which attributes can be used to predict if a patient has diabetes?**

    This is relevant for a heart failure prediction data analysis project presentation. Diabetes is a significant comorbidity and risk factor for heart failure, and identifying patients with diabetes is crucial for proper management and treatment planning. By analyzing attributes such as age, body mass index, blood glucose levels, medication history, and other relevant factors, researchers may be able to develop predictive models to identify individuals with a higher likelihood of having diabetes. This information can guide targeted screening and early intervention, potentially slowing the progression of heart failure and reducing the risk of complications associated with undiagnosed or poorly controlled diabetes. Addressing this question aligns with the goal of improving patient outcomes by enabling early identification and appropriate management of comorbidities that can exacerbate heart failure.

    We can see which attributes can be used to predict diabetes in a patient by using one of several different classification models, such as a logistic regression model, decision tree, or svm model, with all of the patient's attributes as the independent variables and diabetes as the dependent variable. If the attributes have a significant relationship with diabetes, then they will have p-values that are less than 0.05.

    ```{r}
    #Look at p-values of attributes
    test_model <- glm(diabetes ~ ., data = train_data, family = binomial)
    summary(test_model)
    ```

    ```{r}
    set.seed(124)
    train_indices <- sample(1:nrow(heart), 0.7 * nrow(heart)) 
    test_indices <- setdiff(1:nrow(heart), train_indices)  
    train_data <- heart[train_indices, ]
    test_data <- heart[test_indices, ]

    train_data$diabetes <- factor(train_data$diabetes)
    test_data$diabetes <- factor(test_data$diabetes)

    #Logistic Regression Model

    log_model <- glm(diabetes ~ platelets, data = train_data, family = binomial)
    summary(log_model)
    log_predictions <- predict(log_model, newdata = test_data, type = "response")

    log_predicted_classes <- ifelse(log_predictions > 0.5, "1", "0")
    print(paste("Logistic Regression Accuracy: ", mean(log_predicted_classes == test_data$diabetes)))

    log_predicted_classes <- factor(log_predicted_classes)
    log_conf_matrix <- confusionMatrix(log_predicted_classes, test_data$diabetes, positive = "1")
    print(log_conf_matrix)


    #-----------------------------------------------------------
    #SVM

    svm_model <- train(
      diabetes ~ platelets , data = train_data, method = "svmLinear",
      trControl = trainControl(method = "cv", number = 10),
      preProcess = c("center","scale")
    )

    svm_predictions <- svm_model |> predict(test_data)

    print(paste("SVM Accuracy: ", mean(svm_predictions == test_data$diabetes)))

    svm_conf_matrix <- confusionMatrix(svm_predictions, test_data$diabetes, positive = "1")
    print(svm_conf_matrix)

    #-----------------------------------------------------------
    #Decision Tree

    dec_model <- rpart(diabetes ~ platelets, data = train_data, method="class")

    dec_predicted_classes <- dec_model |>
      predict(test_data, type="class")
    print(paste("Decision Tree Accuracy: ", mean(dec_predicted_classes == test_data$DEATH_EVENT)))

    dec_conf_matrix <- confusionMatrix(dec_predicted_classes, test_data$diabetes, positive = "1")
    print(dec_conf_matrix)


    #----------------------------------------------------------
    #ROC
    res.roc <- roc(as.numeric(test_data$diabetes), as.numeric(log_predicted_classes))
    plot.roc(res.roc, print.auc = TRUE)

    res.roc <- roc(as.numeric(test_data$diabetes), as.numeric(svm_predictions))
    plot.roc(res.roc, print.auc = TRUE)

    res.roc <- roc(as.numeric(test_data$diabetes), as.numeric(dec_predicted_classes))
    plot.roc(res.roc, print.auc = TRUE)

    ```

    The only significant attribute is platelets, with a p-value of 0.015. Using Logistic Regression, SVM, and Decision Tree models, we can see that the accuracy is less than 60% for all the models. Logistic Regression and SVM have the highest spensitivity, with values of 1, while the Decision Tree is the best model for high specificity, with a value of 0.6875. Because of the relatively low accuracy rate, we can conclude that none of the attributes in this data set could reliably predict whether a patient has diabetes or not.

5.  **What is the best predictor of follow-up time in heart failure patients among the available biochemical parameters?**

    Follow-up time is ptentially important for a heart failure prediction. Identifying biochemical markers that can reliably predict the length of follow-up time in heart failure patients can have significant clinical implications. Longer follow-up times may indicate a more severe or progressive form of heart failure, requiring closer monitoring and more aggressive treatment strategies. Conversely, shorter follow-up times could suggest a better prognosis or response to treatment. By identifying the best biochemical predictor(s), healthcare providers can stratify patients based on their risk profiles, allocate resources efficiently, and tailor management plans accordingly. This question aligns with the goal of improving patient outcomes by enabling personalized care and optimizing resource utilization based on objective biochemical markers and their predictive power for follow-up time.

    If we want to predict follow-up time, we can create a prediction model using a multiple regression model of the different attributes. We would need to create the model and use a portion of the data set to train.

    ```{r}
    df <- heart
    # Calculate the correlation matrix
    correlations <- cor(df[, c("creatinine_phosphokinase", "ejection_fraction", "platelets", "serum_creatinine", "serum_sodium", "time")], use = "pairwise.complete.obs")

    # Extract the correlations with 'time' feature
    correlation_with_time <- correlations["time", ]

    # Drop the correlation of 'time' with itself
    correlation_with_time <- correlation_with_time[-which(names(correlation_with_time) == "time")]

    # Print the correlations
    print(correlation_with_time)


    df <- heart
    # Calculate the correlation matrix

    ```

    Among these, Serum Sodium shows the strongest positive correlation with follow-up time, although it's still relatively weak. This suggests that among the biochemical parameters considered, Serum Sodium has the best (but still limited) predictive power regarding follow-up time in heart failure patients. ​​

6.  **Is there a relation between smoking and creatinine phosphokinase, serum creatine, and serum sodium?**

    The question regarding the relationship between smoking and biomarkers such as creatinine phosphokinase, serum creatine, and serum sodium is very important. These biomarkers can provide insights into muscle damage, kidney function, and electrolyte imbalances, which are often associated with cardiovascular diseases, including heart failure. Smoking is a well-known risk factor for various health complications, including heart disease. Understanding the potential correlations between smoking and these biomarkers may help identify potential predictors or indicators of heart failure risk, which could aid in early detection and intervention strategies. This question was chosen to explore the potential impact of smoking on these biomarkers and their relevance in the context of heart failure prediction.

    ```{r}
    manova_result <- manova(cbind(creatinine_phosphokinase, serum_creatinine, serum_sodium) ~ smoking, data = heart)
    summary(manova_result)
    ```

    Based on the MANOVA result there is no statistically significant relationship when considering the factors together, as indicated by the high p-value in the MANOVA test result.

    A second question could be “Is there a relation between smoking and creatinine phosphokinase, serum creatinine, and serum sodium individually?”

    ```{r}
    # Linear regression 
    lm_cp <- lm(creatinine_phosphokinase ~ smoking, data = heart)
    summary(lm_cp)

    lm_sc <- lm(serum_creatinine ~ smoking, data = heart)
    summary(lm_sc)

    lm_ss <- lm(serum_sodium ~ smoking, data = heart)
    summary(lm_ss)
    ```

    Therefore, based on the results, the conclusion is that smoking does not have a statistically significant relationship with the levels of creatinine phosphokinase, serum creatinine, or serum sodium individually, and it also does not have a combined effect on these variables as a group.

7.  **How do all of the different attributes affect the rate of mortality from heart failure?**

    The question is crucial because it aims to understand the complex interplay between various factors and the risk of mortality in heart failure patients. By analyzing attributes such as age, comorbidities (e.g., diabetes, hypertension), clinical measurements (e.g., ejection fraction, creatinine levels), and lifestyle factors (e.g., smoking), researchers can identify significant risk factors and potential predictors of mortality. This knowledge can inform risk stratification strategies, targeted interventions, and personalized treatment plans, ultimately improving patient outcomes and survival rates. Addressing this question is essential for developing comprehensive predictive models and gaining insights into the multifaceted nature of heart failure progression and prognosis.

    ```{r}
    library(broom)
    library(ggplot2)
    model <- glm(DEATH_EVENT ~ ., family = binomial(), data = heart)
    summary(model)
    tidied_model <- tidy(model)

    # Calculate confidence intervals
    tidied_model$ci_lower <- tidied_model$estimate - 1.96 * tidied_model$std.error
    tidied_model$ci_upper <- tidied_model$estimate + 1.96 * tidied_model$std.error

    # Create a coefficient plot
    ggplot(tidied_model, aes(x = estimate, y = term, xmin = ci_lower, xmax = ci_upper)) +
      geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
      geom_pointrange() +
      labs(title = "Coefficient Plot of Logistic Regression Model",
           x = "Coefficient Estimate",
           y = "Predictors") +
      theme_minimal()

    ```

    Age: Each additional year in age increased the risk of mortality by about 4.74% (p = 0.0027).

    Anaemia: Presence of anaemia was not significantly associated with mortality (p = 0.983).

    Creatinine Phosphokinase: Higher levels of this enzyme showed a non-significant trend towards increased mortality risk (p = 0.212).

    Diabetes: Diabetes status did not significantly impact mortality rates (p = 0.679).

    Ejection Fraction: Higher ejection fraction, indicating better heart pump function, significantly reduced mortality risk (p \< 0.00001).

    High Blood Pressure: High blood pressure had no significant effect on mortality (p = 0.775).

    Platelets: Platelet count was not significantly associated with mortality (p = 0.525).

    Serum Creatinine: Higher serum creatinine levels were strongly associated with increased risk of mortality (p = 0.000242).

    Serum Sodium: Lower serum sodium levels were marginally associated with increased mortality risk (p = 0.092).

    Sex: There was no significant difference in mortality rates between sexes (p = 0.197).

    Smoking: Smoking status did not significantly affect mortality rates (p = 0.974).

    Time: Longer time since diagnosis was strongly associated with a reduced risk of mortality (p = 2.92e-12).

    1.  **Follow up: Which attribute has the greatest effect on chances of dying from heart failure?**

        Among all the predictors, time since diagnosis had the most significant impact on reducing mortality risk, evidenced by its strong negative association with death events. Physiologically, serum creatinine levels exhibited the greatest positive impact on increasing mortality risk, highlighting its importance in clinical evaluation and management.

8.  **Can we predict if a person was smoking based on all of the other attributes?**

    To determine if we can predict if a patient was smoking based on the attributes in the data set, we first need to determine which attributes have a significant effect on smoking.

    ```{r}
    #Look at p-values of attributes
    test_model <- glm(smoking ~ ., data = train_data, family = binomial)
    summary(test_model)
    ```

    By looking at the p-values, we can see that sex and platelets are the only attributes that have a significant relationship with smoking. For the rest of the attributes, we accept the null hypothesis and conclude that they do not have any significant interaction with smoking. Next, we have to choose which classification model to use to predict the smoking outcomes.

    ```{r}
    #----------------------------------------------
    #set.seed(124)
    train_indices <- sample(1:nrow(heart), 0.7 * nrow(heart)) 
    test_indices <- setdiff(1:nrow(heart), train_indices)  
    train_data <- heart[train_indices, ]
    test_data <- heart[test_indices, ]

    train_data$smoking <- factor(train_data$smoking)
    test_data$smoking <- factor(test_data$smoking)

    #Logistic Regression Model

    log_model <- glm(smoking ~ sex + platelets, data = train_data, family = binomial)
    summary(log_model)
    log_predictions <- predict(log_model, newdata = test_data, type = "response")

    log_predicted_classes <- ifelse(log_predictions > 0.5, "1", "0")
    print(paste("Logistic Regression Accuracy: ", mean(log_predicted_classes == test_data$DEATH_EVENT)))

    log_predicted_classes <- factor(log_predicted_classes)
    log_conf_matrix <- confusionMatrix(log_predicted_classes, test_data$smoking, positive = "1")
    print(log_conf_matrix)


    #-----------------------------------------------------------
    #SVM

    svm_model <- train(
      smoking ~ sex + platelets, data = train_data, method = "svmLinear",
      trControl = trainControl(method = "cv", number = 10),
      preProcess = c("center","scale")
    )

    svm_predictions <- svm_model |> predict(test_data)

    print(paste("SVM Accuracy: ", mean(svm_predictions == test_data$smoking)))

    svm_conf_matrix <- confusionMatrix(svm_predictions, test_data$smoking, positive = "1")
    print(svm_conf_matrix)

    #-----------------------------------------------------------
    #Decision Tree

    dec_model <- rpart(smoking ~ sex + platelets, data = train_data, method="class")

    dec_predicted_classes <- dec_model |>
      predict(test_data, type="class")
    print(paste("Decision Tree Accuracy: ", mean(dec_predicted_classes == test_data$smoking)))

    dec_conf_matrix <- confusionMatrix(dec_predicted_classes, test_data$smoking, positive = "1")
    print(dec_conf_matrix)

    #----------------------------------------------------------
    #ROC
    res.roc <- roc(as.numeric(test_data$smoking), as.numeric(log_predicted_classes))
    plot.roc(res.roc, print.auc = TRUE)

    res.roc <- roc(as.numeric(test_data$smoking), as.numeric(svm_predictions))
    plot.roc(res.roc, print.auc = TRUE)

    res.roc <- roc(as.numeric(test_data$smoking), as.numeric(dec_predicted_classes))
    plot.roc(res.roc, print.auc = TRUE)

    ```

    Because there is no greater cost associated with Type I errors compared to Type II errors, we should look at the overall accuracy of the model to determine which one is the best. We can eliminate the SVM model, as it has a specificity value of 1 and a sensitivity value of 0, which means it will only predict true negatives and false negatives, which is not helpful in prediction. Comparing the logistic model and decision tree, we can see that the logistic model has a higher overall accuracy, which makes it the best choice from the available models. It still has a prediction accuracy of only 65%, so while we can predict if a patient is smoking based on their attributes, there is a large potential for incorrect classification.

9.  **What is the distribution of age among patients who experienced a heart failure death event?**

    This question is highly relevant for a heart failure prediction . Age is a well-established risk factor for cardiovascular diseases, including heart failure. Understanding the age distribution of patients who experienced a fatal outcome can provide valuable insights into the potential age-related vulnerabilities and age-specific risk profiles. This information can guide targeted screening, risk stratification, and tailored management strategies for different age groups. By addressing this question, researchers can identify high-risk age groups and develop age-specific interventions to improve survival rates and quality of life for heart failure patients.

    This question can be answered using visualization to view the distribution of ages for patients who died from heart failure.

    ```{r}
    ggplot(heart, aes(x = age)) +
      geom_histogram(binwidth = 1) +
      facet_wrap(~ DEATH_EVENT) +
      labs(title = "Distribution of Age", x = "Age", y = "Count")

    ```

    -   Mean Age: 65.2 years

    -   Standard Deviation: 13.2 years

    -   Minimum Age: 42 years

    -   25th Percentile: 55 years

    -   Median Age: 65 years

    -   75th Percentile: 75 years

    -   Maximum Age: 95 years

    By using the facet feature to separate the graph for age based on death event, we can see the distribution of ages for those who lived and died from heart failure. The graph of samples who survived is much more concentrated to the left of the graph as compared to the graph of samples who died. The graph of samples who died has a much greater number of samples in the higher ages, which tells us that people who are older are much less likely to survive heart failure than people who are younger.

10. **What are the typical ejection fraction values in patients who survive vs. those who don't?**

    This question is highly relevant for a heart failure prediction. Ejection fraction, a measure of the heart's pumping efficiency, is a critical indicator of cardiac function and a key prognostic factor in heart failure. Comparing ejection fraction values between survivors and non-survivors can provide valuable insights into the relationship between cardiac performance and mortality risk. This information can aid in risk stratification, clinical decision-making, and the development of predictive models for mortality in heart failure patients. Additionally, understanding the typical ejection fraction ranges associated with improved survival can help guide therapeutic interventions aimed at preserving or improving cardiac function, ultimately leading to better patient outcomes.

    T-test, Since this is about comparing the means of a continuous variable (ejection fraction) between two groups (survivors vs. non-survivors), a t-test is appropriate.

    ```{r}
    # Add a group column directly in the data frame for plotting
    heart$group <- ifelse(heart$DEATH_EVENT == 0, "Survivors", "Non-Survivors")
    heart$group <- as.factor(heart$group)

    # Perform the Mann-Whitney U Test
    test_result <- wilcox.test(ejection_fraction ~ group, data = heart, alternative = "two.sided")

    # Output the test result


    # Calculate summary statistics for each group
    summary_stats_survivors <- summary(heart %>% filter(DEATH_EVENT == 0) %>% pull(ejection_fraction))
    summary_stats_non_survivors <- summary(heart %>% filter(DEATH_EVENT == 1) %>% pull(ejection_fraction))

    # Print the summary statistics
    print("Summary Statistics for Survivors:")
    print(summary_stats_survivors)
    print("Summary Statistics for Non-Survivors:")
    print(summary_stats_non_survivors)

    # Identifying outliers using the IQR method
    calculate_outliers <- function(data) {
      Q1 <- quantile(data, 0.25)
      Q3 <- quantile(data, 0.75)
      IQR <- Q3 - Q1
      lower_bound <- Q1 - 1.5 * IQR
      upper_bound <- Q3 + 1.5 * IQR
      return(data[data < lower_bound | data > upper_bound])
    }

    outliers_survivors <- calculate_outliers(heart %>% filter(DEATH_EVENT == 0) %>% pull(ejection_fraction))
    outliers_non_survivors <- calculate_outliers(heart %>% filter(DEATH_EVENT == 1) %>% pull(ejection_fraction))

    # Print the outliers
    print("Outliers for Survivors:")
    print(outliers_survivors)
    print("Outliers for Non-Survivors:")
    print(outliers_non_survivors)


    # Create a boxplot
    ggplot(heart, aes(x = group, y = ejection_fraction, fill = group)) +
      geom_boxplot() +
      labs(title = "Comparison of Ejection Fraction Values",
           x = "Group",
           y = "Ejection Fraction") +
      theme_minimal()
    ```

    Mann-Whitney U test was chosen due to its suitability for comparing two independent samples which may not follow a normal distribution.

    The results of the Wilcoxon rank sum test are as follows:

    W statistic: 13176 P-value: 7.368×10\^(−7)

    The data shows that survivors generally have higher ejection fractions than non-survivors, with median values of 38.00% for survivors and 30.00% for non-survivors. This difference is significant and supports the medical understanding that higher ejection fractions are associated with better cardiovascular health and outcomes. The analysis clearly demonstrates the difference in ejection fractions between survivors and non-survivors of heart failure, with survivors showing generally better heart function. This underlines the importance of the ejection fraction as a prognostic indicator in heart failure management.
